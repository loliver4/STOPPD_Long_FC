---
title: "STOPPD Longitudinal rsFC"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r, message=FALSE, warning=FALSE, results=FALSE}
library(splitstackshape)
library(tidyr)
library(dplyr)
library(corrr)
library(psych)
library(tableone)
library(corrplot)
library(ggplot2)

```

```{r, warning=FALSE, results=FALSE}
# set working dir
setwd("/projects/loliver/STOPPD_Long_FC/data/processed")

# find baseline RS time series files  # pattern glob2rx("sub-?????????_ses-01_run-*_RS_2mm_glasser_tian_meants.csv")
# subject IDs with 10 characters are for control repeat/longitudinal scans (extra R in the ID)
files_RS_ts1 <- list.files(path= ".", recursive=T, full.names=F, pattern="^sub-........._ses-01_run-.*_RS_2mm_glasser_tian_meants\\.csv$")

# confirm csvs aren't empty
files_RS_ts1[file.size(files_RS_ts1) == 0]

# create list of IDs
ptlist1 <- substring(files_RS_ts1,8,13)

# read in time series files
RS_ts1 <- lapply(files_RS_ts1, read.csv, header=F)

# transpose dfs
RS_ts1 <- lapply(RS_ts1, t)

# Name dfs with participant IDs
names(RS_ts1) <- ptlist1

```

```{r, warning=FALSE, results=FALSE}
# set working dir
setwd("/projects/loliver/STOPPD_Long_FC/data/processed")

# find patient longitudinal RS time series files  # pattern glob2rx("sub-?????????_ses-02_run-*_RS_2mm_glasser_tian_meants.csv")
# subject IDs with 10 characters are for control repeat/longitudinal scans (extra R in the ID)
files_RS_ts2 <- list.files(path= ".", recursive=T, full.names=F, pattern="^sub-........._ses-02_run-.*_RS_2mm_glasser_tian_meants\\.csv$")

# confirm csvs aren't empty
files_RS_ts2[file.size(files_RS_ts2) == 0]

# create list of IDs
ptlist2 <- substring(files_RS_ts2,8,13)

# read in time series files
RS_ts2 <- lapply(files_RS_ts2, read.csv, header=F)

# transpose dfs
RS_ts2 <- lapply(RS_ts2, t)

# Name dfs with participant IDs
names(RS_ts2) <- ptlist2


# keep only those with both baseline and longitudinal data - not actually necessary atm
#RS_ts1 <- RS_ts1[names(RS_ts1) %in% names(RS_ts2)]

```

```{r}
# read in clinical data for those who passed imaging QC (as per /projects/loliver/STOPPD_Long_FC/data/raw/stoppd_usable_rsFC_sublist_Nick.csv)
# original csv generated by Erin for the JAMA Psych paper
stpd_clin <- read.csv(file = "/projects/loliver/STOPPD_Long_FC/data/raw/STOPPD_clinical_fc.csv", header=T) %>%
  mutate(STUDYID = as.character(STUDYID),
         dateDiff = as.numeric(dateDiff),
         site = as.factor(site),
         RandomArm = factor(randomization, 
                           levels = c("O", "P"), labels = c("Olanzapine", "Placebo")),
         sex = factor(sex, levels = c("M", "F"), labels = c("Male", "Female")),
         ClinicalOutcome = factor(ClinicalOutcome, 
                             levels = c("Remission","Relapse", "Off protocol")),
         PlotLabel = factor(PlotLabel, 
                       levels = c("Sustained Remisson","Relapse", "Discontinued_Remission"),
                       labels = c("Sustained Remisson","Relapse", "Discontinued"))) 


# exclude 210012 (116 TRs vs 206), 210013 (116 TRs), 220002 (116 TRs), and 320006 (146 TRs) due to incomplete RS ses-01 data
# 220002 also has incomplete RS ses-02 data (116 TRs)  
stpd_clin <- stpd_clin[stpd_clin$STUDYID!="210012" & stpd_clin$STUDYID!="210013" & stpd_clin$STUDYID!="220002" & stpd_clin$STUDYID!="320006",]

# exclude 410012 and 320032 due to intracranial findings
stpd_clin <- stpd_clin[stpd_clin$STUDYID!="410012" & stpd_clin$STUDYID!="320032",]

# keep conn data for eligible participants who passed QC
RS_ts1 <- RS_ts1[names(RS_ts1) %in% stpd_clin$STUDYID]
RS_ts2 <- RS_ts2[names(RS_ts2) %in% stpd_clin$STUDYID]

# identify participant with missing conn data - sub-CMH420018 was missing fmriprep func data for ses-01 in the archive, but this exists now
stpd_clin[!(stpd_clin$STUDYID %in% names(RS_ts1)),]

# read in Tian and Glasser ROI labels (392)
rois <- read.csv(file = "/projects/loliver/STOPPD_Long_FC/data/raw/Glasser_Tian_roi_info.csv", header=T)

```


```{r}
# generate baseline correlation matrices for each participant
cor_rs1  <- lapply(RS_ts1, cor)

# fisher z transform corrs to normalize dist
cor_rs1_z  <- lapply(cor_rs1, fisherz)

# add ROI names and replace inf values with 0 (diagonals set to zero when thresholding in matlab anyway)
for (i in names(cor_rs1_z)) {
  colnames(cor_rs1_z[[i]]) <- as.vector(rois$atlas_roi)
  rownames(cor_rs1_z[[i]]) <- as.vector(rois$atlas_roi)
  cor_rs1_z[[i]][is.infinite(cor_rs1_z[[i]])] <- 0
}

# check out negative values - about 50% negative (total length: 153664; keep in mind GSR applied)
for (i in names(cor_rs1_z)){
  print((length(cor_rs1_z[[i]][cor_rs1_z[[i]]<0])))
  print(summary(cor_rs1_z[[i]][cor_rs1_z[[i]]<0]))
}

# check for NAs - none
for (i in names(cor_rs1_z)){
  print(cor_rs1_z[[i]][is.na(cor_rs1_z[[i]])])
}

# cortical ROIs only
cor_rs1_z_cort <- lapply(cor_rs1_z, "[", 33:392, 33:392)

# subcortical ROIs only
cor_rs1_z_sub <- lapply(cor_rs1_z, "[", 1:32, 1:32)

# write unthresholded individual conn matrices for use in matlab (BCT) 
#setwd("/projects/loliver/STOPPD_Long_FC/data/processed/conn_matrices/full/ses-01")

#for (i in names(cor_rs1_z)) {
#  write.table(cor_rs1_z[[i]],file=paste0(i,"_whole.csv"),row.names = F,col.names = F,sep=",")   
#}

# cortical ROIs only
#for (i in names(cor_rs1_z_cort)) {
#  write.table(cor_rs1_z_cort[[i]],file=paste0(i,"_cortical.csv"),row.names = F,col.names = F,sep=",")   
#}

# subcortical ROIs only
#for (i in names(cor_rs1_z_sub)) {
#  write.table(cor_rs1_z_sub[[i]],file=paste0(i,"_subcortical.csv"),row.names = F,col.names = F,sep=",")     
#}

```

```{r}
# generate longitudinal correlation matrices for each participant
cor_rs2  <- lapply(RS_ts2, cor)

# fisher z transform corrs to normalize dist
cor_rs2_z  <- lapply(cor_rs2, fisherz)

# add ROI names and replace inf values with 0 (diagonals set to zero when thresholding in matlab anyway)
for (i in names(cor_rs2_z)) {
  colnames(cor_rs2_z[[i]]) <- as.vector(rois$atlas_roi)
  rownames(cor_rs2_z[[i]]) <- as.vector(rois$atlas_roi)
  cor_rs2_z[[i]][is.infinite(cor_rs2_z[[i]])] <- 0
}

# check out negative values - about 50% negative (total length: 153664; keep in mind GSR applied)
for (i in names(cor_rs2_z)){
  print((length(cor_rs2_z[[i]][cor_rs2_z[[i]]<0])))
  print(summary(cor_rs2_z[[i]][cor_rs2_z[[i]]<0]))
}

# check for NAs - none
for (i in names(cor_rs2_z)){
  print(cor_rs2_z[[i]][is.na(cor_rs2_z[[i]])])
}

# cortical ROIs only
cor_rs2_z_cort <- lapply(cor_rs2_z, "[", 33:392, 33:392)

# subcortical ROIs only
cor_rs2_z_sub <- lapply(cor_rs2_z, "[", 1:32, 1:32)

# write unthresholded individual conn matrices for use in matlab (BCT) 
#setwd("/projects/loliver/STOPPD_Long_FC/data/processed/conn_matrices/full/ses-02")

#for (i in names(cor_rs2_z)) {
#  write.table(cor_rs2_z[[i]],file=paste0(i,"_whole.csv"),row.names = F,col.names = F,sep=",")   
#}

# cortical ROIs only
#for (i in names(cor_rs2_z_cort)) {
#  write.table(cor_rs2_z_cort[[i]],file=paste0(i,"_cortical.csv"),row.names = F,col.names = F,sep=",")   
#}

# subcortical ROIs only
#for (i in names(cor_rs2_z_sub)) {
#  write.table(cor_rs2_z_sub[[i]],file=paste0(i,"_subcortical.csv"),row.names = F,col.names = F,sep=",")     
#}

```


Same as above with ComBat.

```{r, results=FALSE, message=FALSE}
# prep to run ComBat on baseline data

# add labels to df columns - this will ensure the order is maintained once the data is projected back to an adjacency matrix post-combat
for (i in names(RS_ts1)) {
  colnames(RS_ts1[[i]]) <- rois$order
  RS_ts1[[i]] <- data.frame(RS_ts1[[i]])
}

# generate baseline correlation matrices for each participant for use in Combat
rs1_cor <- lapply(RS_ts1, correlate)

# set upper triangle to NA
rs1_cor <- lapply(rs1_cor, shave)

# create dfs with corrs for each participant
rs1_cor_str <- lapply(rs1_cor, stretch, na.rm=F)
rs1_cor_stru <- lapply(rs1_cor_str, unite, col="rois", 1:2, sep="-", remove=T)
rs1_cor_df <- lapply(rs1_cor_stru, data.frame)

# change col 1 to row names and transpose to get each participant's data in one row
cor_names <- as.vector(rs1_cor_df[[1]][,1])

for (i in names(rs1_cor_df)) {
  rs1_cor_df[[i]] <- data.frame(rs1_cor_df[[i]][,2])
  rs1_cor_df[[i]] <- t(rs1_cor_df[[i]])
  colnames(rs1_cor_df[[i]]) <- cor_names
}

# bind rows across df list to generate tibble with all corrs for each participant
rs1_corrs <- do.call("rbind",rs1_cor_df)
rownames(rs1_corrs) <- names(rs1_cor_df)

# remove columns with only NAs
rs1_corrs <- rs1_corrs[,colSums(is.na(rs1_corrs)) != nrow(rs1_corrs)]

# fisher z transform corrs
rs1_corrs_z  <- fisherz(rs1_corrs)

```

```{r}
# run ComBat on baseline connectivity data to harmonize across scanners
library(neuroCombat)

# change subids as data frame variable names can't start with a number
# dat is a data matrix of the data to harmonize - rows are features (connections) and columns are participants
rownames(rs1_corrs_z) <- paste("sub", rownames(rs1_corrs_z), sep = "_")
rs1_corrs_com <- as.matrix(t(rs1_corrs_z))

# mod is a design matrix specifying biological covariates that should be protected - here treatment arm, sex, age
# order of conn data is not the same as clinical data   
modcombat <- model.matrix(~ RandomArm + sex + age, data=stpd_clin)

# R run ComBat
# batch is a vector (length should be equal to the number of columns in the data matrix) that specifies the id for the batch, site, or scanner to correct for
rs1_combat <- neuroCombat(dat=rs1_corrs_com, batch=as.vector(stpd_clin$site), mod=modcombat)

# add rois column to harmonized data frame and separate
rs1_combat_data <- data.frame(rs1_combat$dat.combat)
rs1_combat_data$rois <- rownames(rs1_combat_data)
rs1_combat_data <- rs1_combat_data %>% separate(rois, into=c("to","from"), sep="-")

library(netdiffuseR)
# rename columns
edgelist <- rs1_combat_data[,c("to","from")]
colnames(edgelist) <- c("ego","alter")

# convert unique edge list back to adjacency matrix for each participant - Note: edgelist_to_adjmat sorts the edges alphabetically
rs1_combat_list <- list()

for (i in colnames(rs1_combat_data[,1:58])) {
  rs1_combat_list[[i]] <- as.matrix(edgelist_to_adjmat(edgelist,w=as.vector(rs1_combat_data[,i]),undirected=T))
  colnames(rs1_combat_list[[i]]) <- rois$atlas_roi
  rownames(rs1_combat_list[[i]]) <- rois$atlas_roi
}

# remove sub_ in IDs 
names(rs1_combat_list) <- c(stpd_clin$STUDYID)

# cortical ROIs only 
rs1_combat_list_cort <- lapply(rs1_combat_list, "[", 33:392, 33:392)

# subcortical ROIs only
rs1_combat_list_sub <- lapply(rs1_combat_list, "[", 1:32, 1:32)

# check out negative values - about 50% negative (total length: 153664; keep in mind GSR applied)
for (i in names(rs1_combat_list)){
  print((length(rs1_combat_list[[i]][rs1_combat_list[[i]]<0])))
  print(summary(rs1_combat_list[[i]][rs1_combat_list[[i]]<0]))
}

# check for NAs - none
for (i in names(rs1_combat_list)){
  print(rs1_combat_list[[i]][is.na(rs1_combat_list[[i]])])
}

# write unthresholded individual conn matrices for use in matlab (BCT) 
#setwd("/projects/loliver/STOPPD_Long_FC/data/processed/conn_matrices/combat/ses-01")

#for (i in names(rs1_combat_list)) {
#  write.table(rs1_combat_list[[i]],file=paste0(i,"_whole.csv"),row.names = F,col.names = F,sep=",")   
#}

# cortical ROIs only
#for (i in names(rs1_combat_list_cort)) {
#  write.table(rs1_combat_list_cort[[i]],file=paste0(i,"_cortical.csv"),row.names = F,col.names = F,sep=",")   
#}

# subcortical ROIs only
#for (i in names(rs1_combat_list_sub)) {
#  write.table(rs1_combat_list_sub[[i]],file=paste0(i,"_subcortical.csv"),row.names = F,col.names = F,sep=",")   
#}

```

```{r, results=FALSE, message=FALSE}
# prep to run ComBat on longitudinal data

# add labels to df columns - this will ensure the order is maintained once the data is projected back to an adjacency matrix post-combat
for (i in names(RS_ts2)) {
  colnames(RS_ts2[[i]]) <- rois$order
  RS_ts2[[i]] <- data.frame(RS_ts2[[i]])
}

# generate longitudinal correlation matrices for each participant for use in Combat
rs2_cor <- lapply(RS_ts2, correlate)

# set upper triangle to NA
rs2_cor <- lapply(rs2_cor, shave)

# create dfs with corrs for each participant
rs2_cor_str <- lapply(rs2_cor, stretch, na.rm=F)
rs2_cor_stru <- lapply(rs2_cor_str, unite, col="rois", 1:2, sep="-", remove=T)
rs2_cor_df <- lapply(rs2_cor_stru, data.frame)

# change col 1 to row names and transpose to get each participant's data in one row
cor_names2 <- as.vector(rs2_cor_df[[1]][,1])

for (i in names(rs2_cor_df)) {
  rs2_cor_df[[i]] <- data.frame(rs2_cor_df[[i]][,2])
  rs2_cor_df[[i]] <- t(rs2_cor_df[[i]])
  colnames(rs2_cor_df[[i]]) <- cor_names2
}

# bind rows across df list to generate tibble with all corrs for each participant
rs2_corrs <- do.call("rbind",rs2_cor_df)
rownames(rs2_corrs) <- names(rs2_cor_df)

# remove columns with only NAs
rs2_corrs <- rs2_corrs[,colSums(is.na(rs2_corrs)) != nrow(rs2_corrs)]

# fisher z transform corrs
rs2_corrs_z  <- fisherz(rs2_corrs)

```

```{r}
# run ComBat on longitudinal connectivity data to harmonize across scanners
library(neuroCombat)

# change subids as data frame variable names can't start with a number
# dat is a data matrix of the data to harmonize - rows are features (connections) and columns are participants
rownames(rs2_corrs_z) <- paste("sub", rownames(rs2_corrs_z), sep = "_")
rs2_corrs_com <- as.matrix(t(rs2_corrs_z))

# mod is a design matrix specifying biological covariates that should be protected - here treatment arm, sex, age
# order of conn data is not the same as clinical data   
modcombat <- model.matrix(~ RandomArm + sex + age, data=stpd_clin)

# R run ComBat # same error when try with svapkg ComBat function
# batch is a vector (length should be equal to the number of columns in the data matrix) that specifies the id for the batch, site, or scanner to correct for
rs2_combat <- neuroCombat(dat=rs2_corrs_com, batch=as.vector(stpd_clin$site), mod=modcombat)

# add rois column to harmonized data frame and separate
rs2_combat_data <- data.frame(rs2_combat$dat.combat)
rs2_combat_data$rois <- rownames(rs2_combat_data)
rs2_combat_data <- rs2_combat_data %>% separate(rois, into=c("to","from"), sep="-")

library(netdiffuseR)
# rename columns
edgelist <- rs2_combat_data[,c("to","from")]
colnames(edgelist) <- c("ego","alter")

# convert unique edge list back to adjacency matrix for each participant - Note: edgelist_to_adjmat sorts the edges alphabetically
rs2_combat_list <- list()

for (i in colnames(rs2_combat_data[,1:58])) {
  rs2_combat_list[[i]] <- as.matrix(edgelist_to_adjmat(edgelist,w=as.vector(rs2_combat_data[,i]),undirected=T))
  colnames(rs2_combat_list[[i]]) <- rois$atlas_roi
  rownames(rs2_combat_list[[i]]) <- rois$atlas_roi
}

# remove sub_ in IDs 
names(rs2_combat_list) <- c(stpd_clin$STUDYID)

# cortical ROIs only 
rs2_combat_list_cort <- lapply(rs2_combat_list, "[", 33:392, 33:392)

# subcortical ROIs only
rs2_combat_list_sub <- lapply(rs2_combat_list, "[", 1:32, 1:32)

# check out negative values - about 50% negative (total length: 153664; keep in mind GSR applied)
for (i in names(rs2_combat_list)){
  print((length(rs2_combat_list[[i]][rs2_combat_list[[i]]<0])))
  print(summary(rs2_combat_list[[i]][rs2_combat_list[[i]]<0]))
}

# check for NAs - none
for (i in names(rs2_combat_list)){
  print(rs2_combat_list[[i]][is.na(rs2_combat_list[[i]])])
}

# write unthresholded individual conn matrices for use in matlab (BCT) 
#setwd("/projects/loliver/STOPPD_Long_FC/data/processed/conn_matrices/combat/ses-02")

#for (i in names(rs2_combat_list)) {
#  write.table(rs2_combat_list[[i]],file=paste0(i,"_whole.csv"),row.names = F,col.names = F,sep=",")   
#}

# cortical ROIs only
#for (i in names(rs2_combat_list_cort)) {
#  write.table(rs2_combat_list_cort[[i]],file=paste0(i,"_cortical.csv"),row.names = F,col.names = F,sep=",")   
#}

# subcortical ROIs only
#for (i in names(rs2_combat_list_sub)) {
#  write.table(rs2_combat_list_sub[[i]],file=paste0(i,"_subcortical.csv"),row.names = F,col.names = F,sep=",")   
#}

```



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
